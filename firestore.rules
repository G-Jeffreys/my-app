rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isUser(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    function isFriend(userId, friendId) {
      // For now, allow all authenticated users to message each other
      // TODO: Implement proper friend checking logic
      return request.auth.uid != null && friendId != null;
    }

    function isParticipantInConversation(userId, conversationId) {
      return request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }

    // Users can read and write their own documents
    // Users can only be created if the user is authenticated
    match /users/{userId} {
      allow write: if request.auth.uid == userId;
      allow create: if request.auth.uid != null;
      // Allow everyone to read a limited subset of fields
  		allow get: if request.auth.uid != null && !(request.auth.uid in ['banned_uids...']);
  		allow list: if false;  // still block listing all users

      // Friend requests can be created by anyone, but can only be read by the sender or recipient.
      // Sender can delete their own request. Recipient can update status.
      match /friendRequests/{requestId} {
        allow create: if request.auth.uid == request.resource.data.from;
        allow read: if request.auth.uid == resource.data.from || request.auth.uid == resource.data.to;
        allow update: if request.auth.uid == resource.data.to;
        allow delete: if request.auth.uid == resource.data.from;
      }

      // Friends subcollection can only be read or written to by the parent user
      match /friends/{friendId} {
        allow read, write: if request.auth.uid == userId;
      }
      
      // Blocked users subcollection can only be read or written to by the parent user
      match /blockedUsers/{blockedId} {
          allow read, write: if request.auth.uid == userId;
      }
    }

    // Enhanced Messages - support both individual and group messaging
    match /messages/{messageId} {
      // Create: sender can create messages (temporarily simplified for debugging)
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.senderId;
      
      // Read: authenticated users can read messages (temporarily simplified for debugging)
      allow read: if request.auth.uid != null;
      
      // Update: only recipients can update (for viewed status, etc.)
      allow update: if (exists(resource.data.recipientId) && request.auth.uid == resource.data.recipientId) ||
        (exists(resource.data.conversationId) && 
         isParticipantInConversation(request.auth.uid, resource.data.conversationId));
      
      // Delete: only system functions can delete (for TTL cleanup)
      allow delete: if false;
    }

    // Receipts for tracking receivedAt timestamps
    match /receipts/{receiptId} {
      // Create: both sender and recipient can create receipts 
      // This allows senders to create receipts for recipients during message sending
      allow create: if request.auth.uid != null &&
        (
          // Individual message: sender or recipient can create receipt
          (exists(request.resource.data.messageId) &&
           (request.auth.uid == get(/databases/$(database)/documents/messages/$(request.resource.data.messageId)).data.senderId ||
            request.auth.uid == get(/databases/$(database)/documents/messages/$(request.resource.data.messageId)).data.recipientId)) ||
          // Group message: participant in conversation can create receipt
          (exists(request.resource.data.conversationId) &&
           isParticipantInConversation(request.auth.uid, request.resource.data.conversationId))
        );
      
      // Read/Update: only the user who owns the receipt
      allow read, update: if request.auth.uid == resource.data.userId;
      
      // Delete: only system functions can delete
      allow delete: if false;
    }

    // Conversations for group chats
    match /conversations/{conversationId} {
      // Create: authenticated user can create conversation
      allow create: if request.auth.uid != null && 
        request.auth.uid == request.resource.data.createdBy &&
        request.auth.uid in request.resource.data.participantIds &&
        request.resource.data.participantIds.size() <= 5 && // Max 5 participants
        request.resource.data.participantIds.size() >= 2;   // Min 2 participants
      
      // Read: only participants can read
      allow read: if request.auth.uid in resource.data.participantIds;
      
      // Update: only participants can update (for name changes, etc.)
      allow update: if request.auth.uid in resource.data.participantIds &&
        request.auth.uid in request.resource.data.participantIds; // Must remain a participant
      
      // Delete: only creator can delete (or system)
      allow delete: if request.auth.uid == resource.data.createdBy;
    }

    // Phase 2: LLM Summaries (read-only for users, write-only for system)
    match /summaries/{summaryId} {
      // Read: users involved in the original message can read summaries
      // For now, allow authenticated users to read (proper filtering happens in client)
      // TODO: Add more restrictive rules based on message participation
      allow read: if request.auth.uid != null;
      
      // Create/Update/Delete: only system functions (Cloud Run worker)
      allow create, update, delete: if false;
    }

    // Future: RAG chunks for group conversations (read-only for users)
    match /ragChunks/{chunkId} {
      // Read: participants in the conversation can read
      allow read: if exists(resource.data.conversationId) &&
        isParticipantInConversation(request.auth.uid, resource.data.conversationId);
      
      // Create/Update/Delete: only system functions
      allow create, update, delete: if false;
    }

    // Global friend requests (moved from users subcollection for easier querying)
    match /friendRequests/{requestId} {
      allow create: if request.auth.uid == request.resource.data.senderId;
      allow read: if request.auth.uid == resource.data.senderId || 
                     request.auth.uid == resource.data.recipientId;
      allow update: if request.auth.uid == resource.data.recipientId;
      allow delete: if request.auth.uid == resource.data.senderId;
    }
  }
} 