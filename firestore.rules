rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isUser(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    function isFriend(userId, friendId) {
      // For now, allow all authenticated users to message each other
      // TODO: Implement proper friend checking logic
      return request.auth.uid != null && friendId != null;
    }

    function isParticipantInConversation(userId, conversationId) {
      return request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }

    // Users can read and write their own documents
    // Users can only be created if the user is authenticated
    match /users/{userId} {
      allow write: if request.auth.uid == userId;
      allow create: if request.auth.uid != null;
      // Allow everyone to read a limited subset of fields
  		allow get: if request.auth.uid != null && !(request.auth.uid in ['banned_uids...']);
  		// Allow authenticated users to search for users (for friend requests)
  		// Note: Client-side should implement proper filtering and limits
  		allow list: if request.auth.uid != null;

      // Legacy nested friend requests - removed, using global collection only

      // Friends subcollection can only be read or written to by the parent user
      match /friends/{friendId} {
        allow read, write: if request.auth.uid == userId;
      }
      
      // Blocked users subcollection can only be read or written to by the parent user
      match /blockedUsers/{blockedId} {
          allow read, write: if request.auth.uid == userId;
      }
    }

    // Enhanced Messages - support both individual and group messaging
    match /messages/{messageId} {
      // Create: sender can create messages (temporarily simplified for debugging)
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.senderId;
      
      // Read: authenticated users can read messages (temporarily simplified for debugging)
      allow read: if request.auth.uid != null;
      
      // Update: only recipients can update (for viewed status, etc.)
      allow update: if (exists(resource.data.recipientId) && request.auth.uid == resource.data.recipientId) ||
        (exists(resource.data.conversationId) && 
         isParticipantInConversation(request.auth.uid, resource.data.conversationId));
      
      // Delete: only system functions can delete (for TTL cleanup)
      allow delete: if false;
    }

    // Receipts for tracking receivedAt timestamps  
    match /receipts/{receiptId} {
      // Create: authenticated users can create receipts
      // Receipt ID format: {messageId}_{userId} ensures ownership
      allow create: if request.auth.uid != null && 
        request.resource.data.userId == request.auth.uid;
      
      // Read: allow if the receipt belongs to the current user OR doesn't exist yet
      // This fixes the permission error when listening for non-existent receipts
      allow read: if request.auth.uid != null && 
        (resource == null || request.auth.uid == resource.data.userId);
      
      // Update: only the user who owns the receipt
      allow update: if request.auth.uid != null && 
        request.auth.uid == resource.data.userId;
      
      // Delete: only system functions can delete
      allow delete: if false;
    }

    // Conversations for group chats
    match /conversations/{conversationId} {
      // Create: authenticated user can create conversation
      allow create: if request.auth.uid != null && 
        request.auth.uid == request.resource.data.createdBy &&
        request.auth.uid in request.resource.data.participantIds &&
        request.resource.data.participantIds.size() <= 5 && // Max 5 participants
        request.resource.data.participantIds.size() >= 2;   // Min 2 participants
      
      // Read: only participants can read
      allow read: if request.auth.uid in resource.data.participantIds;
      
      // Update: only participants can update (for name changes, etc.)
      allow update: if request.auth.uid in resource.data.participantIds &&
        request.auth.uid in request.resource.data.participantIds; // Must remain a participant
      
      // Delete: only creator can delete (or system)
      allow delete: if request.auth.uid == resource.data.createdBy;
    }

    // Phase 2: LLM Summaries (read-only for users, write-only for system)
    match /summaries/{summaryId} {
      // Read: users involved in the original message can read summaries
      // For now, allow authenticated users to read (proper filtering happens in client)
      // TODO: Add more restrictive rules based on message participation
      allow read: if request.auth.uid != null;
      
      // Create/Update/Delete: only system functions (Cloud Run worker)
      allow create, update, delete: if false;
    }

    // Future: RAG chunks for group conversations (read-only for users)
    match /ragChunks/{chunkId} {
      // Read: participants in the conversation can read
      allow read: if exists(resource.data.conversationId) &&
        isParticipantInConversation(request.auth.uid, resource.data.conversationId);
      
      // Create/Update/Delete: only system functions
      allow create, update, delete: if false;
    }

    // Global friend requests (moved from users subcollection for easier querying)
    match /friendRequests/{requestId} {
      allow create: if request.auth.uid == request.resource.data.senderId;
      allow read: if request.auth.uid == resource.data.senderId || 
                     request.auth.uid == resource.data.recipientId;
      allow update: if request.auth.uid == resource.data.recipientId;
      allow delete: if request.auth.uid == resource.data.senderId;
    }
  }
} 