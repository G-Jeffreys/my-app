rules_version = '2';

// FIXED: Firebase Storage Security Rules - Reliable with proper security
service firebase.storage {
  match /b/{bucket}/o {
    
    // System service account function
    function isSystemServiceAccount() {
      return request.auth == null || 
             request.auth.uid == null;
    }
    
    // Media files: photos, videos - handle creation flow timing issues
    match /messages/{messageId}/{fileName} {
      // Read: authenticated users can read files
      // (Additional access control is handled by Firestore message rules)
      allow read: if request.auth != null;
      
      // Write: Allow authenticated users to upload
      // Security rationale: messageId is generated by the client and only the sender
      // creates the message document. The Firestore rules ensure message creation security.
      // This avoids timing issues between Firestore write and Storage upload.
      allow write: if request.auth != null;
      
      // Delete: only system (for TTL cleanup)
      allow delete: if isSystemServiceAccount();
    }
    
    // Media files: direct upload path (for upload-first flow)
    match /messages/{fileName} {
      // Read: authenticated users can read files
      allow read: if request.auth != null;
      
      // Write: Allow authenticated users to upload
      // Used for upload-first flow to avoid timing issues with AI processing
      allow write: if request.auth != null;
      
      // Delete: only system (for TTL cleanup)
      allow delete: if isSystemServiceAccount();
    }
    
    // Profile pictures and other user media
    match /users/{userId}/{fileName} {
      // Read: any authenticated user (for profile pics in UI)
      allow read: if request.auth != null;
      
      // Write: only the user themselves
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Delete: user themselves or system
      allow delete: if (request.auth != null && request.auth.uid == userId) || isSystemServiceAccount();
    }
    
    // Fallback: deny everything else
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
} 