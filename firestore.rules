rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isUser(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    function isFriend(userId, friendId) {
      return exists(/databases/$(database)/documents/users/$(userId)/friends/$(friendId));
    }

    function isParticipantInConversation(userId, conversationId) {
      return request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }

    // Users can read and write their own documents
    // Users can only be created if the user is authenticated
    match /users/{userId} {
      allow read, write: if request.auth.uid == userId;
      allow create: if request.auth.uid != null;

      // Friend requests can be created by anyone, but can only be read by the sender or recipient.
      // Sender can delete their own request. Recipient can update status.
      match /friendRequests/{requestId} {
        allow create: if request.auth.uid == request.resource.data.from;
        allow read: if request.auth.uid == resource.data.from || request.auth.uid == resource.data.to;
        allow update: if request.auth.uid == resource.data.to;
        allow delete: if request.auth.uid == resource.data.from;
      }

      // Friends subcollection can only be read or written to by the parent user
      match /friends/{friendId} {
        allow read, write: if request.auth.uid == userId;
      }
      
      // Blocked users subcollection can only be read or written to by the parent user
      match /blockedUsers/{blockedId} {
          allow read, write: if request.auth.uid == userId;
      }
    }

    // Enhanced Messages - support both individual and group messaging
    match /messages/{messageId} {
      // Create: sender can create messages
      allow create: if request.auth.uid == request.resource.data.senderId &&
        (
          // Individual message: must be friends with recipient
          (exists(request.resource.data.recipientId) && 
           isFriend(request.auth.uid, request.resource.data.recipientId)) ||
          // Group message: must be participant in conversation
          (exists(request.resource.data.conversationId) && 
           isParticipantInConversation(request.auth.uid, request.resource.data.conversationId))
        );
      
      // Read: sender, individual recipient, or group participants can read
      allow read: if request.auth.uid == resource.data.senderId ||
        (exists(resource.data.recipientId) && request.auth.uid == resource.data.recipientId) ||
        (exists(resource.data.conversationId) && 
         isParticipantInConversation(request.auth.uid, resource.data.conversationId));
      
      // Update: only recipients can update (for viewed status, etc.)
      allow update: if (exists(resource.data.recipientId) && request.auth.uid == resource.data.recipientId) ||
        (exists(resource.data.conversationId) && 
         isParticipantInConversation(request.auth.uid, resource.data.conversationId));
      
      // Delete: only system functions can delete (for TTL cleanup)
      allow delete: if false;
    }

    // Receipts for tracking receivedAt timestamps
    match /receipts/{receiptId} {
      // Create: recipient can create receipt when they receive a message
      allow create: if request.auth.uid == request.resource.data.userId &&
        (
          // Individual message: check message exists and user is recipient
          (exists(request.resource.data.messageId) &&
           request.auth.uid in [get(/databases/$(database)/documents/messages/$(request.resource.data.messageId)).data.recipientId]) ||
          // Group message: check user is participant in conversation
          (exists(request.resource.data.conversationId) &&
           isParticipantInConversation(request.auth.uid, request.resource.data.conversationId))
        );
      
      // Read/Update: only the user who owns the receipt
      allow read, update: if request.auth.uid == resource.data.userId;
      
      // Delete: only system functions can delete
      allow delete: if false;
    }

    // Conversations for group chats
    match /conversations/{conversationId} {
      // Create: authenticated user can create conversation
      allow create: if request.auth.uid != null && 
        request.auth.uid == request.resource.data.createdBy &&
        request.auth.uid in request.resource.data.participantIds &&
        request.resource.data.participantIds.size() <= 5 && // Max 5 participants
        request.resource.data.participantIds.size() >= 2;   // Min 2 participants
      
      // Read: only participants can read
      allow read: if request.auth.uid in resource.data.participantIds;
      
      // Update: only participants can update (for name changes, etc.)
      allow update: if request.auth.uid in resource.data.participantIds &&
        request.auth.uid in request.resource.data.participantIds; // Must remain a participant
      
      // Delete: only creator can delete (or system)
      allow delete: if request.auth.uid == resource.data.createdBy;
    }

    // Future: LLM Summaries (read-only for users, write-only for system)
    match /summaries/{summaryId} {
      // Read: users involved in the original message can read summaries
      allow read: if request.auth.uid != null; // TODO: Restrict to message participants
      
      // Create/Update/Delete: only system functions
      allow create, update, delete: if false;
    }

    // Future: RAG chunks for group conversations (read-only for users)
    match /ragChunks/{chunkId} {
      // Read: participants in the conversation can read
      allow read: if exists(resource.data.conversationId) &&
        isParticipantInConversation(request.auth.uid, resource.data.conversationId);
      
      // Create/Update/Delete: only system functions
      allow create, update, delete: if false;
    }

    // Global friend requests (moved from users subcollection for easier querying)
    match /friendRequests/{requestId} {
      allow create: if request.auth.uid == request.resource.data.senderId;
      allow read: if request.auth.uid == resource.data.senderId || 
                     request.auth.uid == resource.data.recipientId;
      allow update: if request.auth.uid == resource.data.recipientId;
      allow delete: if request.auth.uid == resource.data.senderId;
    }
  }
} 